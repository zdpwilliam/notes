package com.william.base;import com.google.common.collect.*;import com.google.common.primitives.Ints;/** * Created by william on 2016/12/31. *//** *  Guava 用类型 Range 表示区间。所有区间实现都是不可变类型。 *  构建区间        由 Range 类的静态方法获取 *  区间运算        Range 的基本运算是它的 contains(C)方法，和你期望的一样，它用来区间判断是否包含某个值。此外，Range 实例也可以当作     Predicate，并且在函数式编程中使用（译者注：见第 4 章）。任何 Range 实例也都支持 containsAll(Iterable<? extends C>)方法。 *  查询运算     [hasLowerBound()] 和 [hasUpperBound()]	判断区间是否有特定边界，或是无限的；     [lowerBoundType()] 和 [upperBoundType()] 返回区间边界类型，CLOSED 或 OPEN；如果区间没有对应的边界，抛出 IllegalStateException；     [lowerEndpoint()] 和 [upperEndpoint()]	返回区间的端点值；如果区间没有对应的边界，抛出 IllegalStateException；     [isEmpty()]	判断是否为空区间。 *  关系运算：   包含[enclose]，相连[isConnected]，交集[intersection]        [enclose] 区间之间的最基本关系就是包含[encloses(Range)]：如果内区间的边界没有超出外区间的边界，则外区间包含内区间。    包含是一种偏序关系[partial ordering]。        Range.isConnected(Range)判断区间是否是相连的。具体来说，isConnected 测试是否有区间同时包含于这两个区间，这等    同于数学上的定义”两个区间的并集是连续集合的形式”（空区间的特殊情况除外）。相连是一种自反的[reflexive]、对称的    [symmetric]关系。        Range.intersection(Range)返回两个区间的交集：既包含于第一个区间，又包含于另一个区间的最大区间。当且仅当两个    区间是相连的，它们才有交集。如果两个区间没有交集，该方法将抛出 IllegalArgumentException。交集是可互换的[commutative] 、    关联的[associative] 运算[operation]。 *  跨区间[span]        Range.span(Range)返回”同时包括两个区间的最小区间”，如果两个区间相连，那就是它们的并集。span 是    可互换的[commutative] 、关联的[associative] 、闭合的[closed]运算[operation]。 *  离散域        部分（但不是全部）可比较类型是离散的，即区间的上下边界都是可枚举的。        在 Guava 中，用 DiscreteDomain实现类型 C 的离散形式操作。一个离散域总是代表某种类型值的全集；    它不能代表类似”素数”、”长度为 5 的字符串”或”午夜的时间戳”这样的局部域。        DiscreteDomain 提供的离散域实例包括：         类型	     离散域         Integer	 integers()         Long	     longs()        一旦获取了 DiscreteDomain 实例，你就可以使用下面的 Range 运算方法：        ContiguousSet.create(range, domain)：用 ImmutableSortedSet 形式表示 Range 中符合离散域定义的元素，并增加一些    额外操作——译者注：实际返回 ImmutableSortedSet 的子类 ContiguousSet。（对无限区间不起作用，除非类型 C 本身是有限的，    比如 int 就是可枚举的）        canonical(domain)：把离散域转为区间的”规范形式”。如果 ContiguousSet.create(a, domain).equals(    ContiguousSet.create(b, domain))并且!a.isEmpty()，则有 a.canonical(domain).equals(b.canonical(domain))。    （这并不意味着 a.equals(b)）        注意，ContiguousSet.create 并没有真的构造了整个集合，而是返回了 set 形式的区间视图。 *  自定义的离散域；但必须记住 DiscreteDomain 契约的几个重要方面。        一个离散域总是代表某种类型值的全集；它不能代表类似”素数”或”长度为 5 的字符串”这样的局部域。所以举例来说，    你无法构造一个 DiscreteDomain 以表示精确到秒的 JODA DateTime 日期集合：因为那将无法包含 JODA DateTime 的所有值。        DiscreteDomain 可能是无限的——比如 BigInteger DiscreteDomain。这种情况下，你应当用 minValue()和 maxValue()    的默认实现，它们会抛出 NoSuchElementException。但 Guava 禁止把无限区间传入 ContiguousSet.create        ——译者注：那明显得不到一个可枚举的集合。 *  如果我需要一个Comparator呢？        我们想要在 Range 的可用性与 API 复杂性之间找到特定的平衡，这部分导致了我们没有提供基于 Comparator 的接口：    我们不需要操心区间是怎样基于不同 Comparator 互动的；所有 API 签名都是简单明确的；这样更好。    另一方面，如果你需要任意 Comparator，可以按下列其中一项来做：        使用通用的 Predicate 接口，而不是 Range 类。（Range 现了 Predicate 接口，因此可以用Predicates.compose(range,    function)获取 Predicate 实例）        使用包装类以定义期望的排序。        译者注：实际上 Range 规定元素类型必须是 Comparable，这已经满足了大多数需求。如果需要自定义特殊的比较逻辑，可以用     Predicates.compose(range, function)组合比较的 function。 */public class RangeTest {    public static void main(String[] args) {        Range.downTo(4, BoundType.CLOSED);                           // (a..+∞)或[a..+∞)，取决于boundType        Range.range(1, BoundType.CLOSED, 4, BoundType.OPEN);        // [1..4)，等同于Range.closedOpen(1, 4)        Range.closed("left", "right"); //字典序在"left"和"right"之间的字符串，闭区间        Range.lessThan(4.0);             //严格小于4.0的double值        Range.closed(1, 3).contains(2);//return true        Range.closed(1, 3).contains(4);//return false        Range.lessThan(5).contains(5); //return false        Range.closed(1, 4).containsAll(Ints.asList(1, 2, 3)); //return true        Range.closedOpen(4, 4).isEmpty();   // returns true        Range.openClosed(4, 4).isEmpty();   // returns true        Range.closed(4, 4).isEmpty();       // returns false//        Range.open(4, 4).isEmpty();         // Range.open throws IllegalArgumentException        Range.closed(3, 10).lowerEndpoint(); // returns 3        Range.open(3, 10).lowerEndpoint(); // returns 3        Range.closed(3, 10).lowerBoundType(); // returns CLOSED        Range.open(3, 10).upperBoundType(); // returns OPEN        Range.closed(3, 5).isConnected(Range.open(5, 10)); // returns true        Range.closed(0, 9).isConnected(Range.closed(3, 4)); // returns true        Range.closed(0, 5).isConnected(Range.closed(3, 9)); // returns true        Range.open(3, 5).isConnected(Range.open(5, 10)); // returns false        Range.closed(1, 5).isConnected(Range.closed(6, 10)); // returns false        Range.closed(3, 5).intersection(Range.open(5, 10)); // returns (5, 5]        Range.closed(0, 9).intersection(Range.closed(3, 4)); // returns [3, 4]        Range.closed(0, 5).intersection(Range.closed(3, 9)); // returns [3, 5]//        Range.open(3, 5).intersection(Range.open(5, 10)); // throws IAE//        Range.closed(1, 5).intersection(Range.closed(6, 10)); // throws IAE        Range.closed(3, 5).span(Range.open(5, 10)); // returns [3, 10)        Range.closed(0, 9).span(Range.closed(3, 4)); // returns [0, 9]        Range.closed(0, 5).span(Range.closed(3, 9)); // returns [0, 9]        Range.open(3, 5).span(Range.open(5, 10)); // returns (3, 10)        Range.closed(1, 5).span(Range.closed(6, 10)); // returns [1, 10]        ImmutableSortedSet set = ContiguousSet.create(Range.open(1, 5), DiscreteDomain.integers());        System.out.println(set);        //set包含[2, 3, 4]        set = ContiguousSet.create(Range.greaterThan(0), DiscreteDomain.integers());        System.out.println(set);        //set包含[1, 2, ..., Integer.MAX_VALUE]    }}