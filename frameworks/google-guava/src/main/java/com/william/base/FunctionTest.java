package com.william.base;import com.google.common.base.*;import com.google.common.collect.*;import com.google.common.primitives.Doubles;import java.util.HashSet;import java.util.Map;import java.util.Set;import java.util.concurrent.TimeUnit;/** * Created by william on 2016/12/28. */public class FunctionTest {    public static void main(String[] args) {        function();        supply();    }    /**     *      过度使用 Guava 函数式编程会导致冗长、混乱、可读性差而且低效的代码。这是迄今为止最容易（也是最经常）被滥用的     * 部分，如果你想通过函数式风格达成一行代码，致使这行代码长到荒唐，Guava 团队会泪流满面。     *     *      截至 JDK7，命令式代码仍应是默认和第一选择。不应该随便使用函数式风格，除非你绝对确定以下两点之一：     *  1、使用函数式风格以后，整个工程的代码行会净减少。在上面的例子中，函数式版本用了 11 行， 命令式代码用了 6 行，     *  把函数的定义放到另一个文件或常量中，并不能帮助减少总代码行。     *  2、为了提高效率，转换集合的结果需要懒视图，而不是明确计算过的集合。此外，确保你已经阅读和重读了 Effective Java     *  的第 55 条，并且除了阅读本章后面的说明，你还真正做了性能测试并且有测试数据来证明函数式版本更快。     *     *  Guava 提供两个基本的函数式接口：     *      Function<A, B>，它声明了单个方法 B apply(A input)。Function 对象通常被预期为引用透明的——没有副作用——并且     *  引用透明性中的”相等”语义与 equals 一致，如 a.equals(b)意味着 function.apply(a).equals(function.apply(b))。     *      Predicate，它声明了单个方法 boolean apply(T input)。Predicate 对象通常也被预期为无副作用函数，并且”相等”     *  语义与 equals 一致。     */    /**     * Functions     */    public static void function() {        final Map<Double, Double> eurPriceMap = Maps.newHashMap();        eurPriceMap.put(2001D, 500D);        eurPriceMap.put(2002D, 200D);        eurPriceMap.put(2003D, 100D);        System.out.println(eurPriceMap);        Map<Double, Double> priceResult = Maps.transformValues(eurPriceMap,                new Function<Double, Double>() {                    double eurToUsd = 1.4888;                    public Double apply(Double from) {                        System.out.println("from ---- " + from);                        return from * eurToUsd;                    }                });        System.out.println(priceResult);        Map<String, String> goodPriceMap = Maps.newHashMap();        goodPriceMap.put("apple", "500D");        goodPriceMap.put("orange", "200D");        goodPriceMap.put("pineapple", "200D");        System.out.println(goodPriceMap);        Multimap<String, String> resultMap = Multimaps.transformEntries(Multimaps.forMap(goodPriceMap),                new Maps.EntryTransformer<String, String, String>() {                    double eurToUsd = 1.4888;                    public String transformEntry(String key, String value) {                        System.out.println(key + value);                        return key + "-" + String.valueOf(Double.valueOf(value) * eurToUsd);                    }                });        System.out.println(resultMap);        Map<String, State> stateMap = Maps.newHashMap();        stateMap.put("SH", new State("上海", "2201", Sets.newHashSet("浦东", "黄浦", "徐汇")));        stateMap.put("BJ", new State("北京", "2202", Sets.newHashSet("海淀", "青云")));        stateMap.put("HN", new State("河南", "2203", Sets.newHashSet("郑州", "开封", "兰考", "洛阳")));        //  Functions.forMap()方法：        Function<String, State> lookup = Functions.forMap(stateMap);        System.out.println(lookup.apply("HN"));        System.out.println();//      System.out.println(lookup.apply("HH"));        /**         *      使用Functions.forMap方法有一个警告。如果传入的key在map当中不存在会抛出IllegalArgumentException异常。然而，         * 有一个重载的forMap方法增加一个默认值参数，如果key没找到会返回默认值。通过使用Function接口来执行state的查找，         * 你可以很容易的改变这个实现。当我们使用Splitter对象来创建一个map或者使用Guava collection包中其他的一些方法来创建map，         * 总之我们可以在我们代码当中借住Guava的力量。         */        //  Functions.compose()        Function<State, String> stateFunction = new Function<State, String>(){// 将州的城市转换为字符串            public String apply(State state) {                return Joiner.on(",").join(state.getMainCities());            }        };        Function<String, String> stateCitiesFunction = Functions.compose(stateFunction, lookup); //组合Function        System.out.println(stateCitiesFunction.apply("SH"));        System.out.println();        System.out.println(Functions.toStringFunction().apply(lookup.apply("HN")));    }    /**     * SupplierDemo接口     * public interface Supplier<T>{     *     T get();     * }     * get方法返回T的是一个实例，每次get调用可以返回相同的实例（单例）也可以每次返回新实例。     * Supplier接口提供了一个灵活的延迟初始化机制直到get方法被调用。     *     * Supplier<T> Suppliers.memoize(Supplier<T> delegate)     * 对delegate进行包装，对其get调用将返回delegate.get的执行结果，只有第一次调用时delegate.get会被     * 执行，Supplier<T>会缓存delegate.get的结果，后面的调用将返回缓存，即单例模式。     *     * Supplier<T> memoizeWithExpiration(Supplier<T> delegate, long duration, TimeUnit unit)     * 功能与memoize相同，但是缓存的结果具有时效性。     *     *     * 1.可以考虑使实体实现Supplier接口，用get作为其实例化方法     * 2.可以考虑Supplier接口和Suppliers.memoize方法组合，实现单例模式     * 3.可以考虑Supplier接口和Suppliers.memoizeWithExpiration方法组合，每隔一段时间更新缓存的数据     *      深入的学习还是看源码，当做一个基础工具的时候，可以考虑引入Guava，当写一个新的方法时可以考虑看看Guava有没有     * 现成的^_^,如果没有，仍然推荐使用Guava实现一个Guava风格的方法。     */    public static void supply() {        final Predicate<State> statePredicate = new Predicate<State>(){            public boolean apply(State state) {                return state.getMainCities().contains("开封");            }        };        Supplier<Predicate<String>> composedPredicateSupplier= new Supplier<Predicate<String>>() {            public Predicate<String> get() {                State shState = new State("上海", "2201", Sets.newHashSet("浦东", "黄浦", "徐汇"));                State hnState =  new State("河南", "2203", Sets.newHashSet("郑州", "开封", "兰考", "洛阳"));                Map<String,State> stateMap = Maps.newHashMap();                stateMap.put(shState.getCode(), shState);                stateMap.put(hnState.getCode(), hnState);                Function<String,State> mf = Functions.forMap(stateMap);                return Predicates.compose(statePredicate, mf);            }        };        Predicate<String> predicate = composedPredicateSupplier.get();        boolean isHN = predicate.apply("2203");        System.out.println(isHN);        Predicate<String> predicate1 = composedPredicateSupplier.get();        System.out.println(predicate == predicate1);        // Supplier wrapped对象只初始化一次        Supplier<Predicate<String>> wrapped = Suppliers.memoize(composedPredicateSupplier);        Predicate<String> predicate2 = wrapped.get();        Predicate<String> predicate3 = wrapped.get();        System.out.println(predicate2 == predicate3);        // 可以使用memoizeWithExpiration函数创建过期设置的Supplier对象，时间过期，get对象会重新初始化对象        Suppliers.memoizeWithExpiration(composedPredicateSupplier, 10, TimeUnit.MILLISECONDS);        /**         *      Suppliers的特性可以用来对程序中只需要初始化一次的资源进行管理，比如数据库管理对象，当然，         * 用户也可以根据需求选择是否需要定时更新对象，总而言之，Suppliers给我们编程带来了更多的选择。         */        Supplier<String> str = Suppliers.ofInstance("张苏纳");        System.out.println(str.get());        Supplier<Object> objectSupplier = Suppliers.ofInstance(Object.class.cast("张苏纳"));        System.out.println(Suppliers.supplierFunction().apply(objectSupplier));        // 返回一个Function，接收一个Supplier返回其调用get方法后的结果。//        Suppliers.synchronizedSupplier(); // 返回一个Supplier，保证在调用get方法时加锁同步，是线程安全的。    }    static class State {        private String name;        private String code;        private Set<String> mainCities = new HashSet<String>();        public State() {        }        public State(String name, String code, Set<String> mainCities) {            this.name = name;            this.code = code;            this.mainCities = mainCities;        }        public String getName() {            return name;        }        public void setName(String name) {            this.name = name;        }        public Set<String> getMainCities() {            return mainCities;        }        public void setMainCities(Set<String> mainCities) {            this.mainCities = mainCities;        }        public String getCode() {            return code;        }        public void setCode(String code) {            this.code = code;        }        @Override        public String toString() {            return "State{" +                    "name='" + name + '\'' +                    ", code='" + code + '\'' +                    ", mainCities=" + mainCities +                    '}';        }    }}