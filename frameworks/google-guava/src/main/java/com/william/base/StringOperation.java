package com.william.base;import com.google.common.base.*;import com.google.common.collect.Collections2;import com.google.common.collect.ImmutableMap;import com.google.common.collect.Lists;import java.util.ArrayList;import java.util.Arrays;import java.util.List;import java.util.Map;/** * Created by william on 2016/12/27. */public class StringOperation {    public static void main(String[] args) {        stringJoiner();        stringSpilter();        charMatcher();        charsets();        caseFormat();    }    /**     * Joiner 连接器     * 用分隔符把字符串序列连接起来也可能会遇上不必要的麻烦。如果字符串序列中含有 null，那连接操作会更难。     * Fluent 风格的 Joiner 让连接字符串更简单。     */    public static void stringJoiner() {        Joiner joiner = Joiner.on("; ").skipNulls();        // joiner.withKeyValueSeparator(":");        System.out.println(joiner.join("Harry", 1, "Ron", "Hermione"));        /*            上述代码返回”Harry; Ron; Hermione”。另外，useForNull(String)方法可以给定某个字符串来替换 null，        而不像 skipNulls()方法是直接忽略 null。 Joiner 也可以用来连接对象类型，在这种情况下，它会把对象的        toString()值连接起来。         */        System.out.println(Joiner.on(",").join(Arrays.asList(1, 5, 7)));        //警告：joiner 实例总是不可变的。用来定义 joiner 目标语义的配置方法总会返回一个新的 joiner 实例。        //  这使得 joiner 实例都是线程安全的，你可以将其定义为 static final常量。        StringBuilder sb = new StringBuilder();        System.out.println(joiner.appendTo(sb, Arrays.asList(2, 3, 4)));        Joiner mapJoiner = Joiner.on(", ");        System.out.println(mapJoiner.withKeyValueSeparator(":").join(string2Map().entrySet()));        List<String> strArr = Lists.newArrayList(                " test1", "test2 ", " test3 ", null, "test4", null, null, "", "  ");        Predicate<String> EMPTY_OR_NULL_FILTER = new Predicate<String>() {            public boolean apply(String str){                str = Strings.nullToEmpty(str).trim();                return !Strings.isNullOrEmpty(str);            }        };        Function<String, String> TRIM_RESULT = new Function<String, String>(){            public String apply(String str){                return Strings.nullToEmpty(str).trim();            }        };        String joinStr = Joiner.on(';')                .skipNulls()                .join(Collections2.transform(Collections2.filter(strArr, EMPTY_OR_NULL_FILTER), TRIM_RESULT));        System.out.println("joinStr ------- :" + joinStr);    }    private static Map<String, String> string2Map() {        return ImmutableMap.of("id", "2", "name", "zhangsan", "age", "10");    }    /**     * Splitter 拆分器     *  JDK 内建的字符串拆分工具有一些古怪的特性。比如，String.split 悄悄丢弃了尾部的分隔符。 问题：”,a,,b,”.split(“,”)返回？     *   1、“”, “a”, “”, “b”, “”     *   2、null, “a”, null, “b”, null     *   3、“a”, null, “b”     *   4、“a”, “b”     *   5、以上都不对     *   正确答案是 5：””, “a”, “”, “b”。只有尾部的空字符串被忽略了。     */    public static void stringSpilter() {        String testString = ",a,,b,";        System.out.println(Arrays.toString(testString.split(",")));        Iterable<String> testSplit = Splitter.on(",").omitEmptyStrings().trimResults().split(testString);        System.out.println(testSplit.toString());        Iterable<String> results = Splitter.on(',')                .trimResults()                .omitEmptyStrings()                .split("foo,bar,,   qux");        System.out.println(results.toString());        String numbersString = "1, 2, 3, 4, 5";        Iterable<String> split = Splitter.on(",").split(numbersString);        System.out.println(split.toString());        String str = "key1: 1; key2: 2  ; key3: 3";        Map<String, String> map = Splitter.on(";")                .trimResults()                .withKeyValueSeparator(":")                .split(str);        System.out.println(map.toString());    }    /**     * CharMatcher 字符匹配器    有些人形容它：“像打了兴奋剂的StringUtils”     *     *      为了收拾“StringUtil 类疯狂地膨胀”这个泥潭，我们开发了 CharMatcher。     *     *      直观上，你可以认为一个 CharMatcher 实例代表着某一类字符，如数字或空白字符。事实上来说，     * CharMatcher 实例就是对字符的布尔判断——CharMatcher 确实也实现了 Predicate——但类似”所有空白字符”或”     * 所有小写字母”的需求太普遍了，Guava 因此创建了这一 API。     *      然而使用 CharMatcher 的好处更在于它提供了一系列方法，让你对字符作特定类型的操作：修剪[trim]、折叠[collapse]、     * 移除[remove]、保留[retain]等等。     *      CharMatcher 实例首先代表概念     *      1：怎么才算匹配字符？然后它还提供了很多操作概念     *      2：如何处理这些匹配字符？这样的设计使得 API 复杂度的线性增加可以带来灵活性和功能两方面的增长。     */    public static void charMatcher() {        String string = "controller /u0061/u4E2D/u6587";        String noControl = CharMatcher.JAVA_ISO_CONTROL.removeFrom(string);    //移除control字符        System.out.println(noControl);        String theDigits = CharMatcher.DIGIT.retainFrom(string);                 //只保留数字字符        System.out.println(theDigits);        String spaced = CharMatcher.WHITESPACE.trimAndCollapseFrom(string, ' ');//去除两端的空格，并把中间的连续空格替换成单个空格        System.out.println(spaced);        String noDigits = CharMatcher.JAVA_DIGIT.replaceFrom(string, "*");      //用*号替换所有数字        System.out.println(noDigits);        String lowerAndDigit = CharMatcher.JAVA_DIGIT.or(CharMatcher.JAVA_LOWER_CASE).retainFrom(string); // 只保留数字和小写字母        System.out.println(lowerAndDigit);        System.out.println(CharMatcher.inRange('a', 'z').or(CharMatcher.inRange('A', 'Z')).matches('7'));  // 给定字符范围匹配，如 CharMatcher.inRange(‘a’, ‘z’)        System.out.println(CharMatcher.anyOf("sdfdsfds").matches('s'));         //枚举匹配字符。如 CharMatcher.anyOf(“aeiou”)匹配小写英语元音        System.out.println(CharMatcher.is('A').matches('c'));       //collapseFrom(CharSequence, char)	把每组连续的匹配字符替换为特定字符。如 WHITESPACE.collapseFrom(string,‘ ‘)       //                                   把字符串中的连续空白字符替换为单个空格。       // matchesAllOf(CharSequence)	测试是否字符序列中的所有字符都匹配。       // removeFrom(CharSequence)	从字符序列中移除所有匹配字符。       // retainFrom(CharSequence)	在字符序列中保留匹配字符，移除其他字符。       // trimFrom(CharSequence)	移除字符序列的前导匹配字符和尾部匹配字符。       // replaceFrom(CharSequence, CharSequence)	用特定字符序列替代匹配字符。    }    /*        注：CharMatcher 只处理 char 类型代表的字符；它不能理解 0x10000 到 0x10FFFF 的 Unicode 增补字符。这些逻辑字符以      代理对[surrogate pairs]的形式编码进字符串，而 CharMatcher 只能将这种逻辑字符看待成两个独立的字符。    */    public static void charsets() {        System.out.println("我的知道，并不是所有鸟儿都在飞翔".getBytes(Charsets.UTF_8));    }    public static void caseFormat() {        String data = "test_data";//        System.out.println(CaseFormat.valueOf("_"));  emnu        System.out.println(CaseFormat.LOWER_HYPHEN.to(CaseFormat.LOWER_CAMEL, "test-data"));        System.out.println(CaseFormat.LOWER_UNDERSCORE.to(CaseFormat.LOWER_CAMEL, "test_data"));        System.out.println(CaseFormat.UPPER_UNDERSCORE.to(CaseFormat.UPPER_CAMEL, "test_data"));    }}