package com.william.base;import com.google.common.base.Function;import com.google.common.base.Supplier;import com.google.common.collect.*;import com.google.common.primitives.Ints;import java.util.*;/** * Created by william on 2016/12/28. *//** *     尚未完成: Queues, Tables 工具类 *     任何对 JDK 集合框架有经验的程序员都熟悉和喜欢 java.util.Collections 包含的工具方法。Guava 沿着这些路线提供了 * 更多的工具方法：适用于所有集合的静态方法。这是 Guava 最流行和成熟的部分之一。 * *     我们用相对直观的方式把工具类与特定集合接口的对应关系归纳如下： *     集合接口	            属于JDK还是Guava	        对应的Guava工具类 *     Collection	            JDK	                    Collections2：不要和 java.util.Collections 混淆 *     List	                    JDK	                    Lists *     Set	                    JDK	                    Sets *     SortedSet	            JDK	                    Sets *     Map	                    JDK	                    Maps *     SortedMap	            JDK	                    Maps *     Queue	                JDK	                    Queues *     Multiset	                Guava	                Multisets *     Multimap	                Guava	                Multimaps *     BiMap	                Guava	                Maps *     Table	                Guava	                Tables * */public class NewCollections2Test {    public static void main(String[] args) {        staticFactory();        testIterables();        testMaps();        testMultimaps();        testTable();        collectionExt();    }    /**     *  静态工厂方法     */    public static void staticFactory() {        Set<String> copySet = Sets.newHashSet("william1", "william2", "william3");        List<String> theseElements = Lists.newArrayList("alpha", "beta", "gamma");        // 此外，通过为工厂方法命名（Effective Java 第一条），我们可以提高集合初始化大小的可读性：        List<String> exactly100 = Lists.newArrayListWithCapacity(100);        List<String> approx100 = Lists.newArrayListWithExpectedSize(100);        Set<String> approx100Set = Sets.newHashSetWithExpectedSize(100);        //    注意：Guava 引入的新集合类型没有暴露原始构造器，也没有在工具类中提供初始化方法。而是直接在        // 集合类中提供了静态工厂方法。        Multiset<String> multiset = HashMultiset.create();    }    /**     *      Iterables     *      在可能的情况下，Guava 提供的工具方法更偏向于接受 Iterable 而不是 Collection 类型。在 Google，对于不存放在     *  主存的集合——比如从数据库或其他数据中心收集的结果集，因为实际上还没有攫取全部数据，这类结果集都不能支持类似     *  size()的操作 ——通常都不会用 Collection 类型来表示。     *     *      因此，很多你期望的支持所有集合的操作都在 Iterables 类中。大多数 Iterables 方法有一个在 Iterators 类中的对     *  应版本，用来处理 Iterator。     *      截至 Guava 1.2 版本，Iterables 使用 FluentIterable 类进行了补充，它包装了一个 Iterable 实例，并对许多操作     *  提供了”fluent”（链式调用）语法。     */    public static void testIterables() {        Iterable<Integer> concatenated = Iterables.concat(                Ints.asList(1, 2, 3),                Ints.asList(4, 5, 6)); // concatenated包括元素 1, 2, 3, 4, 5, 6        System.out.println("concatenated list: " + concatenated);        Set<String> mylinkedHashSet = Sets.newLinkedHashSet();        mylinkedHashSet.add("william");        mylinkedHashSet.add("big Boom");        String lastAdded = Iterables.getLast(mylinkedHashSet);        System.out.println("mylinkedHashSet lastAdded: " + lastAdded);        Set<String> thisSetIsDefinitelyASingleton = Sets.newHashSet("william");        String theElement = Iterables.getOnlyElement(thisSetIsDefinitelyASingleton);        System.out.println("thisSetIsDefinitelyASingleton getOnlyElement(): " + theElement);        //如果set不是单元素集，就会出错了！        /*        常规方法:        concat(Iterable<Iterable>)	        串联多个 iterables 的懒视图*	                            concat(Iterable...)        frequency(Iterable, Object)	        返回对象在 iterable 中出现的次数                            与 Collections.frequency (Collection, Object)比较；Multiset        partition(Iterable, int)	        把 iterable 按指定大小分割，得到的子集都不能进行修改操作	Lists.partition(List, int)；paddedPartition(Iterable, int)        getFirst(Iterable, T default)	    返回 iterable 的第一个元素，若 iterable 为空则返回默认值	与Iterable.iterator(). next()比较;FluentIterable.first()        getLast(Iterable)	                返回 iterable 的最后一个元素，若 iterable 为空则抛出        getLast(Iterable, T default)；FluentIterable.last()；                                            NoSuchElementException        elementsEqual(Iterable, Iterable)	如果两个 iterable 中的所有元素相等且顺序一致，返回 true	    与 List.equals(Object)比较        unmodifiableIterable(Iterable)	    返回 iterable 的不可变视图	                                与 Collections. unmodifiableCollection(Collection)比较        limit(Iterable, int)	            限制 iterable 的元素个数限制给定值	                        FluentIterable.limit(int)        getOnlyElement(Iterable)	        获取 iterable 中唯一的元素，如果 iterable 为空或有多个      getOnlyElement(Iterable, T default)                                            元素，则快速失败         */        /*          FluentIterable          除了上面和第四章提到的方法，FluentIterable 还有一些便利方法用来把自己拷贝到不可变集合             ImmutableList             ImmutableSet	        toImmutableSet()             ImmutableSortedSet	    toImmutableSortedSet(Comparator)         */        List countUp = Ints.asList(1, 2, 3, 4, 5);        List countDown = Lists.reverse(countUp);        // {5, 4, 3, 2, 1} 返回给定 List 的反转视图。                                                        // 注: 如果 List 是不可变的，考虑改用 ImmutableList.reverse()。        List<List> parts = Lists.partition(countUp, 2); //{{1,2}, {3,4}, {5}} 把 List 按指定大小分割        System.out.println("countUp : " + countUp);        System.out.println("countDown : " + countDown);        System.out.println("parts : " + parts);        /*        集合理论方法        我们提供了很多标准的集合运算（Set-Theoretic）方法，这些方法接受 Set 参数并返回 SetView，可用于：        直接当作 Set 使用，因为 SetView 也实现了 Set 接口；        用 copyInto(Set) 拷贝进另一个可变集合；        用 [immutableCopy()] 对自己做不可变拷贝。            union(Set, Set)            intersection(Set, Set)            difference(Set, Set)            symmetricDifference(Set, Set)         */        Set<String> wordsWithPrimeLength = ImmutableSet.of("one", "two", "three", "six", "seven", "eight");        System.out.println("wordsWithPrimeLength : " + wordsWithPrimeLength);        Set<String> primes = ImmutableSet.of("two", "three", "five", "seven");        System.out.println("primes : " + primes);        Sets.SetView<String> intersection = Sets.intersection(primes, wordsWithPrimeLength);        System.out.println("intersection : " + intersection);   // intersection包含"two", "three", "seven"        System.out.println(intersection.immutableCopy());         // 可以使用交集，但不可变拷贝的读取效率更高        /*            cartesianProduct(List<Set>)	    返回所有集合的笛卡儿积            powerSet(Set)	                返回给定集合的所有子集         */    }    /**     *      Maps     *      Maps 类有若干值得单独说明的、很酷的方法。     *     *      uniqueIndex     *      Maps.uniqueIndex(Iterable,Function) 通常针对的场景是：有一组对象，它们在某个属性上分别有独一无二的值，     *  而我们希望能够按照这个属性值查找对象——译者注：这个方法返回一个 Map，键为 Function 返回的属性值，值为     *  Iterable 中相应的元素，因此我们可以反复用这个 Map 进行查找操作。     *      如果索引值不是独一无二的，请参见下面的 Multimaps.index 方法。     *     *      difference     *      Maps.difference(Map, Map) 用来比较两个 Map 以获取所有不同点。该方法返回 MapDifference 对象，把不同点的     *  维恩图分解为：     *      entriesInCommon()	    两个 Map 中都有的映射项，包括匹配的键与值     *      entriesDiffering()	    键相同但是值不同值映射项。返回的 Map 的值类型为 MapDifference.ValueDifference，     *                               以表示左右两个不同的值     *      entriesOnlyOnLeft()	键只存在于左边 Map 的映射项     *      entriesOnlyOnRight()	键只存在于右边 Map 的映射项     *     */    public static void testMaps() {        List<String> strings = Lists.newArrayList("will", "william");        ImmutableMap<Integer, String> stringsByIndex = Maps.uniqueIndex(strings,                new Function<String, Integer>() {                    public Integer apply(String input) {                        return input.length();                    }                });        System.out.println("stringsByIndex : " + stringsByIndex);        Map<String, Integer> left = ImmutableMap.of("a", 1, "b", 2);        Map<String, Integer> right = ImmutableMap.of("b", 2, "c", 3);        MapDifference<String, Integer> diff = Maps.difference(left, right);        System.out.println(diff.entriesInCommon());         // {"b" => 2}        System.out.println(diff.entriesInCommon());         // {"b" => 2}        System.out.println(diff.entriesOnlyOnLeft());       // {"a" => 1}        System.out.println(diff.entriesOnlyOnRight());      // {"c" => 3}        Multiset<String> multiset1 = HashMultiset.create();        multiset1.add("a", 2);        Multiset<String> multiset2 = HashMultiset.create();        multiset2.add("a", 5);        System.out.println(multiset1.containsAll(multiset2));   //返回true；因为包含了所有不重复元素，                                                                //虽然multiset1实际上包含2个"a"，而multiset2包含5个"a"        System.out.println(Multisets.containsOccurrences(multiset1, multiset2));    // returns false        Multisets.removeOccurrences(multiset2, multiset1);        System.out.println(multiset2);                          // multiset2 现在包含3个"a"        System.out.println(multiset2.removeAll(multiset1));     // multiset2移除所有"a"，虽然multiset1只有2个"a"        System.out.println(multiset2.isEmpty());                // returns true        /*  Multisets 中的其他工具方法还包括：        copyHighestCountFirst(Multiset)	            返回 Multiset 的不可变拷贝，并将元素按重复出现的次数做降序排列        unmodifiableMultiset(Multiset)	            返回 Multiset 的只读视图        unmodifiableSortedMultiset(SortedMultiset)	返回 SortedMultiset 的只读视图         */        Multiset<String> multiset = HashMultiset.create();        multiset.add("a", 3);        multiset.add("b", 5);        multiset.add("c", 1);        System.out.println(multiset);        ImmutableMultiset highestCountFirst = Multisets.copyHighestCountFirst(multiset);        //highestCountFirst，包括它的entrySet和elementSet，按{"b", "a", "c"}排列元素        System.out.println(highestCountFirst);    }    /**     *      Multimaps     *      Multimaps 提供了若干值得单独说明的通用工具方法:     *      index 作为 Maps.uniqueIndex 的兄弟方法，[Multimaps.index(Iterable, Function)],通常针对的场景是：有一组对象，     *  它们有共同的特定属性，我们希望按照这个属性的值查询对象，但属性值不一定是独一无二的。     *     *      invertFrom 鉴于 Multimap 可以把多个键映射到同一个值（译者注：实际上这是任何 map 都有的特性），也可以把一个     *  键映射到多个值，反转 Multimap 也会很有用。Guava 提供了 invertFrom(Multimap toInvert, Multimap dest) 做这个操作，     *  并且你可以自由选择反转后的 Multimap 实现。     *   注：如果你使用的是 ImmutableMultimap，考虑改用 [ImmutableMultimap.inverse()]     *     *      forMap 想在 Map 对象上使用 Multimap 的方法吗？forMap(Map)把 Map 包装成 SetMultimap。这个方法特别有用，例如，     *  与 Multimaps.invertFrom 结合使用，可以把多对一的 Map 反转为一对多的 Multimap。     *     *      包装器     *      Multimaps 提供了传统的包装方法，以及让你选择 Map 和 Collection 类型以自定义 Multimap 实现的工具方法。     *  只读包装	Multimap	ListMultimap	SetMultimap	    SortedSetMultimap     *  同步包装	Multimap	ListMultimap	SetMultimap	    SortedSetMultimap     *  自定义实现	Multimap	ListMultimap	SetMultimap	    SortedSetMultimap     *     *      自定义 Multimap 的方法允许你指定 Multimap 中的特定实现。但要注意的是：     *      Multimap 假设对 Map 和 Supplier 产生的集合对象有完全所有权。这些自定义对象应避免手动更新，并且在提供给     *  Multimap 时应该是空的，此外还不应该使用软引用、弱引用或虚引用。     *      无法保证修改了 Multimap 以后，底层 Map 的内容是什么样的。     *      即使 Map 和 Supplier 产生的集合都是线程安全的，它们组成的 Multimap 也不能保证并发操作的线程安全性。     *  并发读操作是工作正常的，但需要保证并发读写的话，请考虑用同步包装器解决。     *      只有当 Map、Supplier、Supplier 产生的集合对象、以及 Multimap 存放的键值类型都是可序列化的，Multimap     *  才是可序列化的。     *      Multimap.get(key)返回的集合对象和 Supplier 返回的集合对象并不是同一类型。但如果 Supplier 返回的是随机     *  访问集合，那么 Multimap.get(key)返回的集合也是可随机访问的。     *     *      请注意，用来自定义 Multimap 的方法需要一个 Supplier 参数，以创建崭新的集合。下面有个实现 ListMultimap     *  的例子——用 TreeMap 做映射，而每个键对应的多个值用 LinkedList 存储。     */    public static void testMultimaps() {        ImmutableSet digits = ImmutableSet.of("zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine");        Function<String, Integer> lengthFunction = new Function<String, Integer>() {            public Integer apply(String string) {                return string.length();            }        };        ImmutableListMultimap<Integer, String> digitsByLength = Multimaps.index(digits, lengthFunction);        System.out.println("digitsByLength count: " + digitsByLength);        /*        *  digitsByLength maps:        *  3 => {"one", "two", "six"}        *  4 => {"zero", "four", "five", "nine"}        *  5 => {"three", "seven", "eight"}        */        ArrayListMultimap<String, Integer> multimap = ArrayListMultimap.create();        multimap.putAll("b", Ints.asList(2, 4, 6));        multimap.putAll("a", Ints.asList(4, 2, 1));        multimap.putAll("c", Ints.asList(2, 5, 3));        TreeMultimap<Integer, String> resultMap = TreeMultimap.create();        TreeMultimap<Integer, String> inverse = Multimaps.invertFrom(multimap, resultMap);        System.out.println("multimap inverse : " + inverse);        //注意我们选择的实现，因为选了TreeMultimap，得到的反转结果是有序的        /*        * inverse maps:        *  1 => {"a"}        *  2 => {"a", "b", "c"}        *  3 => {"c"}        *  4 => {"a", "b"}        *  5 => {"c"}        *  6 => {"b"}        */        Map<String, Integer> map = ImmutableMap.of("a", 1, "b", 1, "c", 2);        SetMultimap<String, Integer> setMultimap = Multimaps.forMap(map);        System.out.println("setMultimap : " + setMultimap);        // multimap：["a" => {1}, "b" => {1}, "c" => {2}]        HashMultimap<Integer, String> setResultMultiMap = HashMultimap.create();        Multimap<Integer, String> setInverse = Multimaps.invertFrom(setMultimap, setResultMultiMap);        System.out.println("setMultimap inverse: " + setInverse);        // inverse：[1 => {"a","b"}, 2 => {"c"}]        /* ListMultimap<String, Integer> myMultimap = Multimaps.newListMultimap(                Maps.<String, Collection>newTreeMap(),                new Supplier<LinkedList>() {                    public LinkedList get() {                        return Lists.newLinkedList();                    }                });            System.out.println("ListMultimap : " + myMultimap);        */    }    /**     *  Tables 类提供了若干称手的工具方法。     *      自定义 Table 堪比 Multimaps.newXXXMultimap(Map, Supplier)工具方法，Tables.newCustomTable(Map, Supplier<Map>)     *  允许你指定 Table 用什么样的 map 实现行和列。     *     *      transpose(Table<R, C, V>)方法允许你把 Table<C, R, V>转置成 Table<R, C, V>。例如，如果你在用 Table     * 构建加权有向图，这个方法就可以把有向图反转。     */    public static void testTable() {        // 使用LinkedHashMaps替代HashMaps        Table<String, Character, Integer> table = Tables.newCustomTable(            Maps.<String, Map<Character, Integer>>newLinkedHashMap(),            new Supplier<Map<Character, Integer>> () {                public Map<Character, Integer> get() {                    return Maps.newLinkedHashMap();                }            });        System.out.println("customized table : " + table);        /*            包装器            还有很多你熟悉和喜欢的 Table 包装类。然而，在大多数情况下还请使用 ImmutableTable            Unmodifiable	Table	RowSortedTable         */    }    /**     *      集合扩展工具类     *     *      有时候你需要实现自己的集合扩展。也许你想要在元素被添加到列表时增加特定的行为，或者你想实现一个 Iterable，     *  其底层实际上是遍历数据库查询的结果集。Guava 为你，也为我们自己提供了若干工具方法，以便让类似的工作变得更简单。     *  （毕竟，我们自己也要用这些工具扩展集合框架。）     */    public static void collectionExt() {        /*            PeekingIterator            有时候，普通的 Iterator 接口还不够。            Iterators 提供一个 Iterators.peekingIterator(Iterator)方法，来把 Iterator 包装为 PeekingIterator，这是        Iterator 的子类，它能让你事先窥视[[peek()] 到下一次调用 next()返回的元素。            注意：Iterators.peekingIterator 返回的 PeekingIterator 不支持在 peek()操作之后调用remove()方法。         */        List<String> source = Lists.newArrayList("william1", "william2", "william2","william3");        System.out.println("source : " + source);        List<String> result = Lists.newArrayList();        // 复制一个 List，并去除连续的重复元素。        PeekingIterator<String> iter = Iterators.peekingIterator(source.iterator());        while (iter.hasNext()) {            String current = iter.next();            while (iter.hasNext() && iter.peek().equals(current)) {                //跳过重复的元素                iter.next();            }            result.add(current);        }        System.out.println("source after Duplicate removal result: " + result);        // 传统的实现方式需要记录上一个元素，并在特定情况下后退，但这很难处理且容易出错。相较而言，        // PeekingIterator 在理解和使用上就比较直接了。        /*            AbstractIterator            实现你自己的 Iterator？AbstractIterator 让生活更轻松。            用一个例子来解释 AbstractIterator 最简单。比方说，我们要包装一个 iterator 以跳过空值。            你实现了 computeNext()方法，来计算下一个值。如果循环结束了也没有找到下一个值，请返回         endOfData()表明已经到达迭代的末尾。            注意：AbstractIterator 继承了 UnmodifiableIterator，所以禁止实现 remove()方法。如果你需要支持         remove()的迭代器，就不应该继承 AbstractIterator。         */        List<String> skipNullList = Lists.newArrayList(source);        skipNullList.add(null);        System.out.println("skipNullList source: " + skipNullList);        System.out.println("source skipNulls : " + Lists.newArrayList(skipNulls(skipNullList.iterator())));        /*            AbstractSequentialIterator            有一些迭代器用其他方式表示会更简单。AbstractSequentialIterator 就提供了表示迭代的另一种方式。            我们在这儿实现了 computeNext(T)方法，它能接受前一个值作为参数。            注意，你必须额外传入一个初始值，或者传入 null 让迭代立即结束。因为 computeNext(T)假定 null 值意味着迭代的         末尾——AbstractSequentialIterator 不能用来实现可能返回 null 的迭代器。         */        Iterator<Integer> powersOfTwo = new AbstractSequentialIterator<Integer>(1) { // 注意初始值1!            protected Integer computeNext(Integer previous) {                return (previous == 1 << 30) ? null : previous * 2;            }        };        System.out.println("powersOfTwo : " + Lists.newArrayList(powersOfTwo));    }    public static Iterator<String> skipNulls(final Iterator<String> in) {        return new AbstractIterator<String>() {            protected String computeNext() {                while (in.hasNext()) {                    String s = in.next();                    if (s != null) {                        return s;                    }                }                return endOfData();            }        };    }    /*        Forwarding装饰器        针对所有类型的集合接口，Guava 都提供了 Forwarding 抽象类以简化装饰者模式的使用。        Forwarding 抽象类定义了一个抽象方法：delegate()，你可以覆盖这个方法来返回被装饰对象。所有其他方法都会直接    委托给 delegate()。例如说：ForwardingList.get(int)实际上执行了 delegate().get(int)。        通过创建 ForwardingXXX 的子类并实现 delegate()方法，可以选择性地覆盖子类的方法来增加装饰功能，而不需要自己    委托每个方法——译者注：因为所有方法都默认委托给 delegate()返回的对象，你可以只覆盖需要装饰的方法。        此外，很多集合方法都对应一个”标准方法[standardxxx]”实现，可以用来恢复被装饰对象的默认行为，以提供相同的优    点。比如在扩展 AbstractList 或 JDK 中的其他骨架类时，可以使用类似 standardAddAll 这样的方法。        让我们看看这个例子。假定你想装饰一个 List，让其记录所有添加进来的元素。当然，无论元素是用什么方法——    add(int, E), add(E), 或 addAll(Collection)——添加进来的，我们都希望进行记录，因此我们需要覆盖所有这些方法。     */    class AddLoggingList<E> extends ForwardingList<E> {        List<E> delegate;     // backing list without final        @Override protected List<E> delegate() {            return delegate;        }        @Override public void add(int index, E elem) {            System.out.println(index + "_" + elem);            super.add(index, elem);        }        @Override public boolean add(E elem) {            return standardAdd(elem); // 用add(int, E)实现        }        @Override public boolean addAll(Collection<? extends E> c) {            return standardAddAll(c); // 用add实现        }    }    /*       记住，默认情况下，所有方法都直接转发到被代理对象，因此覆盖 ForwardingMap.put 并不会改变 ForwardingMap.putAll    的行为。小心覆盖所有需要改变行为的方法，并且确保装饰后的集合满足接口契约。       通常来说，类似于 AbstractList 的抽象集合骨架类，其大多数方法在 Forwarding 装饰器中都有对应的”标准方法”实现。       对提供特定视图的接口，Forwarding 装饰器也为这些视图提供了相应的”标准方法”实现。例如，ForwardingMap 提供    StandardKeySet、StandardValues 和 StandardEntrySet 类，它们在可以的情况下都会把自己的方法委托给被装饰的 Map，    把不能委托的声明为抽象方法。     */}